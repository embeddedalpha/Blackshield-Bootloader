/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "main.h"
#include "Console/Console.h"
#include "CRC/CRC.h"
#include "Custom_RS485_Comm/Custom_RS485_Comm.h"


uint8_t buffer1[3] = {0,0,0};
uint8_t buffer[256];

void Download_Firmware(void);


typedef enum _Commands_Typedef_{
	Connect_Device =             0xA1,
	Disconnect_Device =          0xA2,
	Fetch_Info =                 0xA3,
	Write_Firmware =             0xA4,
	Read_Firmware =              0xA5,
	Erase_Firmware =             0xA6,
	Reboot_MCU =                 0xA7
}Commands;

typedef enum _Request_List_{

	Req_Request     = 0x01,
	Req_ACK  		= 0x02,

}Request_List;

Commands Command_RX;
Request_List Req_RX;


void Configuration_App();
void Bootloader(void);
void Application();

int main(void)
{
	MCU_Clock_Setup();
	Delay_Config();
	CRC_Init();

	GPIO_Pin_Init(GPIOC, 0, GPIO_Configuration.Mode.Input, GPIO_Configuration.Output_Type.None, GPIO_Configuration.Speed.None, GPIO_Configuration.Pull.None, GPIO_Configuration.Alternate_Functions.None);

	if((GPIOC -> IDR & GPIO_IDR_ID0) == true)
	{
		Custom_Comm_Init(115200);
		Bootloader();
	}
	else
	{
		Application();
	}

}

void Download_Firmware(void)
{
	//	Send start signal.
	//	Receive size of firmware (4 bytes).
	//	Receive firmware data (loop, chunk-by-chunk).
	//	Verify CRC.
	//	Erase flash.
	//	Write to flash.
	//	Confirm write with read-back (optional).
	//	Acknowledge completion.

	// 1. Send start signal [0xAA][0x55]{[]}[Checksum][0xBB][0xCC]
	// 2. Wait till we receive ACK for this command


}

void Bootloader(void)
{
	while(1)
	{
		uint16_t len = Custom_Comm_Receive(buffer);
		if(buffer[0] == 0xAA && buffer[1] == 0x55)
		{
			if(buffer[0] == 0xAA && buffer[1] == 0x55)
			{
				if(buffer[len-2] == 0xBB && buffer[len-1] == 0x66)
				{
					uint32_t CRC_Rec1 = (((uint32_t)buffer[len-6] << 24) | ((uint32_t)buffer[len-5] << 16) | ((uint32_t)buffer[len-4] << 8) | ((uint32_t)buffer[len-3] << 0)) ;
					uint32_t CRC_Rec2 = CRC_Compute_8Bit_Block(&buffer[2], len-8);
					if(CRC_Rec1 == CRC_Rec2)
					{
						Command_RX = buffer[2];
						Req_RX = buffer[3];
						switch (Command_RX)
						{
							case Connect_Device:
							{

							}
							break;

							case Disconnect_Device:
							{

							}
							break;

							case Fetch_Info:
							{

							}
							break;

							case Write_Firmware:
							{
								Download_Firmware();
							}
							break;

							case Read_Firmware:
							{

							}
							break;

							case Erase_Firmware:
							{

							}
							break;

							case Reboot_MCU:
							{

							}
							break;
						}
					}
				}
			}
		}
	}
}

void Application()
{

}
